<div class="row">

    <div class="col-2">
      <div class="nav flex-column nav-pills" id="v-pills-tab" role="tablist" aria-orientation="vertical">
        <a class="nav-link active" id="v-pills-firebaseangularfirebase-tab" data-toggle="pill" href="#v-pills-firebaseangularfirebase" role="tab" aria-controls="v-pills-firebaseangularfirebase" aria-selected="true">App.module.ts</a>
        <a class="nav-link" id="v-pills-firebaseangularfirebase0-tab" data-toggle="pill" href="#v-pills-firebaseangularfirebase0" role="tab" aria-controls="v-pills-firebaseangularfirebase0" aria-selected="true">Conexión firebase</a>
        <a class="nav-link" id="v-pills-firebaseangularfirebase1-tab" data-toggle="pill" href="#v-pills-firebaseangularfirebase1" role="tab" aria-controls="v-pills-firebaseangularfirebase1" aria-selected="false">Registro + Token</a>
        <a class="nav-link" id="v-pills-firebaseangularfirebase2-tab" data-toggle="pill" href="#v-pills-firebaseangularfirebase2" role="tab" aria-controls="v-pills-firebaseangularfirebase2" aria-selected="false">Login + Token</a>
        <a class="nav-link" id="v-pills-firebaseangularfirebase3-tab" data-toggle="pill" href="#v-pills-firebaseangularfirebase3" role="tab" aria-controls="v-pills-firebaseangularfirebase3" aria-selected="false">x</a>
      </div>
    </div>

    <div class="col-10">
      <div class="tab-content" id="v-pills-tabContent">

        <div class="tab-pane fade show active" id="v-pills-firebaseangularfirebase" role="tabpanel" aria-labelledby="v-pills-firebaseangularfirebase-tab">
         
  <div class="card-group">
    <div class="card text-dark bg-danger m-3">
        <div class="card-body">
  <pre class="card-text blanco">import {{c}} BrowserModule } from '@angular/platform-browser';
import {{c}} NgModule } from '@angular/core';

import {{c}} AppComponent } from './app.component';

import {{c}} routing, appRoutingProviders } from './app.routing';

import {{c}} HomeComponent } from './paginas/home/home.component';
import {{c}} ErrorComponent } from './componentes/error/error.component';
import {{c}} PieComponent } from './componentes/pie/pie.component';
import {{c}} CabeceraComponent } from './componentes/cabecera/cabecera.component';

import {{c}} FormsModule } from '@angular/forms';

//Servicio Http - Conexión con Firebase
<b>import {{c}} HttpClientModule } from '@angular/common/http';</b>

@NgModule({{c}}
    declarations: [
    AppComponent,
    HomeComponent,
      ErrorComponent,
      PieComponent,
      CabeceraComponent
    ],
    imports: [
    BrowserModule,
    routing,
    FormsModule<b>,</b>
    //Servicio Http - Conexión con Firebase
    <b>HttpClientModule</b>
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [AppComponent]
})
export class AppModule {{c}} }</pre>
        </div>
    </div>
</div>

        </div>

        <div class="tab-pane fade" id="v-pills-firebaseangularfirebase0" role="tabpanel" aria-labelledby="v-pills-firebaseangularfirebase0-tab">
          
          Proviene de <a href="https://firebase.google.com/docs/reference/rest/auth#top_of_page"><b>Web Firebase (API REST firebase de autentificación)</b></a> -> <b>Opción lateral</b>
<div class="card-group">
  <div class="card text-dark bg-danger m-3">
    <div class="card-header">
      <pre class="card-text text-center blanco"><h3>Servicio</h3></pre>
    </div>
      <div class="card-body">
        <pre class="card-text blanco">import {{c}} Injectable } from '@angular/core';
<b>import {{c}} HttpClient } from '@angular/common/http';</b>  <abbr title="Usar conexión el url/api con el servicio de http"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

@Injectable({{c}}
  providedIn: 'root'
})
export class ServiciofireService {{c}}

  <b>private url = 'https://identitytoolkit.googleapis.com/v1/accounts:sign';</b> <abbr title="Parte común de las direcciones de abajo"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

  <b>private apikey = 'AIzaSyBXBZUhEffME9i58aVvigvAkSoOgCEfSPg';</b> <abbr title="Cada proyecto lleva una apikey diferente, no copiar la misma en todos. Clave que se encuentra en Configuración -> General -> Clave de API de la web"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

    Copiamos la parte que se repite y lo metemos en la variable url

   //<b>https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY] </b>            //<b>Crear usuario</b>
   //<b>https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY]</b> //<b>Login usuario</b>


  constructor( <b>private http: HttpClient</b> ) {{c}} }  <abbr title="Usar conexión el url/api con el servicio de http"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>


}</pre>
      </div>
  </div>
</div>

        </div>

        <div class="tab-pane fade" id="v-pills-firebaseangularfirebase1" role="tabpanel" aria-labelledby="v-pills-firebaseangularfirebase1-tab"><app-registrofirebaseangularr></app-registrofirebaseangularr>

<div class="card-group">
  <div class="card text-dark bg-danger m-3">
      <div class="card-header">
          <pre class="card-text text-center blanco"><h3>Servicio</h3></pre>
      </div>
      <div class="card-body">
        <pre class="card-text blanco">import {{c}} Injectable } from '@angular/core';
import {{c}} HttpClient } from '@angular/common/http';  
<b>import {{c}} UsuarioModel } from '../../model/usuario.model';</b>  <abbr title="Model, estructura del usuario: email, password..."><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} catchError <abbr title="Captura el error que salga al no coger el dato, usamos variableError.error.error...depende como venga en la API el error"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> , map <abbr title="Coge los datos que necesitamos ['datoNecesario'] que viene de la API para usarlo, se puede ver en consola cuando llamamos a la API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> } from 'rxjs/operators';</b>  

@Injectable({{c}}
  providedIn: 'root'
})

export class ServiciofireService {{c}}

  private url = 'https://identitytoolkit.googleapis.com/v1/accounts:sign'; 

  private apikey = 'AIzaSyBXBZUhEffME9i58aVvigvAkSoOgCEfSPg'; 

  <b>TokenUsuario: string;</b>  <abbr title="Se inicializa sin valor (undefined) porque hasta que no se identifique no obtenemos ningún token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

   //https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]             //Crear usuario
   //https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY] //Login usuario

  constructor( private http: HttpClient ) {{c}} }  


   <b>registrar ( usuario: UsuarioModel ){{c}}</b>  <abbr title="En la documentación pone que necesitaremos email, password y token (que debe ser true para que me devuelva). Email y password viene declarado en el Model y por ello en la variable usuario. https://firebase.google.com/docs/reference/rest/auth -> Request Body Payload -> email, password y returnSecureToken"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

      //Compleja                                  
      /*const authData = {{c}}    <abbr title="Como viene incluido en el model email/password tenemos que declarar el token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            email: usuario.email,   <abbr title="Del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            password: usuario.password, <abbr title="Del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            returnSecureToken: true     <abbr title="Copiamos el token de la web y la declaramos en true"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      };*/              
      
      //Reducida
      <b>const authData = {{c}}</b>  <abbr title="Como viene incluido en el model email/password tenemos que declarar el token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>...usuario,</b>           <abbr title="Del model. coge todos los elementos (...)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>returnSecureToken: true</b>  <abbr title="Copiamos el token de la web y la declaramos en true"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
  }; 
  
    //LLAMA A NUESTRO SERVICIO HTTP POST PARA CREAR

    //Compleja
    /*return this.http.post(    <abbr title="return -> Para poderme subscribirme en otro lugar"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      `${{c}} this.url }Up?key=${{c}} this.apikey }`,   <abbr title="Dirección donde hacemos el post y usamos el servicio API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      authData  <abbr title="Argumento que le enviamos a la dirección (email, password y token)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    );*/

    //Reducida
    <b>return this.http.post(this.url + 'Up?key=' + this.apikey, authData)<abbr title="Dirección común + no común + apikey personal, datos que enviamos"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>//;</b> <abbr title="Quitamos; al añadir pipe + map"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>  
                        <b>.pipe(</b> <abbr title="Tubería donde cogemos todos los datos de la API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

                            <b>map( resp => {{c}}</b>   <abbr title="Dentro del Pipe nos permite usar el map (Transforma la información como queramos o servir solo de intermediario, lee la respuesta y si viene el token lo almacena. La ventaja del map que si el post da un error no se va a disparar)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                              console.log('Entro en el pipe -> map'); 
                              <b>this.guardarToken ( resp ['idToken']);</b> <abbr title="Voy a mandar a guardarToken el ID del token que es lo que obtengo de la API, debe ser exactamente igual escrito"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                              <b>return resp;</b>  <abbr title="Meto en una tuvería (pipe) y filtro (map) lo que quiero obtener (['idToken'])"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                          <b>})</b>/*<b>,</b>

                          <b>catchError(err => {{c}}</b>   <abbr title="Se podría controlar el error, pero ya lo controlamos en el Ts. SI QUEREMOS CONTROLAR EL ERROR AQUÍ O EN EL TS"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                            console.log(<b>err.error.error.message</b>);  <abbr title="Saca el mensaje del error, en este caso es: EMAIL_EXISTS. Sabemos que son varios error al mirar en consola, vemos error y dentro otro error..."><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                            <b>return err;</b>  <abbr title="Sale con el error"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                          <b>})</b>*/
                         <b>);</b>
    <b>}</b>

    /*GUARDAR/LEER  TOKEN*/

      <b>private guardarToken ( IDToken_Recibido: string ){{c}}</b>  <abbr title="Donde guardaremos el Token que recibimos del registro/login cuando es llamado, para luego leerlo y usarlo"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>this.TokenUsuario = IDToken_Recibido; </b> <abbr title="El Id del token recibido lo metemos en la variable TokenUsuario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>localStorage.setItem('AlmacenaToken', IDToken_Recibido);</b> <abbr title="ID Token lo almacenamos en AlmacenaToken, su forma es un string y lo cogemos del IDToken_Recibido"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      <b>}
    
    
    
      leerToken(){{c}}
          if( localStorage.getItem('AlmacenaToken') ){{c}}</b>  <abbr title="Si existe el token que es dado al guardarlo a través de guardarToken"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            <b>this.TokenUsuario = localStorage.getItem('AlmacenaToken');</b>  <abbr title="Metemos en la variable el token que está almacenado si coincide por la condición de arriba"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
          <b>}
          else{{c}}</b>  <abbr title="Si no existe el token almacenado"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            <b>this.TokenUsuario = '';</b>  <abbr title="Lo inicializamos en vacío"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
          <b>}
    
          return this.TokenUsuario;</b>  <abbr title="Devolvemos la variable del token tenga (if) o no tenga (else) token almacenado"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      <b>}</b>

}</pre>
      </div>
  </div>
</div>

<div class="card-group">
  <div class="card text-dark bg-primary m-3">
      <div class="card-header">
          <pre class="card-text text-center"><h3>Ts</h3></pre>
      </div>
      <div class="card-body">
        <pre class="card-text">import {{c}} Component, OnInit } from '@angular/core';
<b>import {{c}} UsuarioModel } from '../../model/usuario.model';</b>  <abbr title="Model del usuario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} NgForm } from '@angular/forms';</b>  <abbr title="Funciones para formularios"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} ServiciofireService } from '../servicio/serviciofire.service';</b>  <abbr title="Servicio donde llamamos a la API y de ese modo conectarnos con el componente"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

@Component({{c}}
  selector: 'app-registrofirebaseangularr',
  templateUrl: './registrofirebaseangularr.component.html',
  styleUrls: ['./registrofirebaseangularr.component.css']
})
export class RegistrofirebaseangularrComponent implements OnInit {{c}}

  <b>usuario: UsuarioModel;</b>  <abbr title="Variable dandole formato del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

  constructor( <b>private auth: ServiciofireService</b> ) {{c}} }  <abbr title="Variable que metemos el servicio dentro"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

  ngOnInit() {{c}}
    <b>this.usuario = new UsuarioModel();</b>  <abbr title="Metemos el model en el usuario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
  }

  <b>GuardarDatos( datoRecibido: NgForm ){{c}}</b>  <abbr title="Función que almacena lo que metemos en el formulario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

    <b>if ( datoRecibido.invalid ){{c}}</b> <abbr title="Si el formulario introducido es invalido se sale"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
          <b>return;</b>
      <b>}</b>
      
      <b>this.auth.registrar(this.usuario).subscribe ( resp => {{c}}</b>
        console.log(resp);
        
       <b>}, (variableRecibirError) => {{c}}</b>  <abbr title="Coge el error recibido. SI QUEREMOS CONTROLAR EL ERROR AQUÍ O EN EL SERVICIO. RECOMEDABLE AQUÍ"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        console.log(<b>variableRecibirError.error.error.message</b>);  <abbr title="Saca el mensaje del error, en este caso es: EMAIL_EXISTS. Sabemos que son varios error al mirar en consola, vemos error y dentro otro error..."><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      <b>}</b>
      
      <b>);</b>

}</pre>
      </div>
  </div>
  <div class="card text-dark bg-warning m-3">
    <div class="card-header">
        <pre class="card-text text-center"><h3>Html</h3></pre>
    </div>
    <div class="card-body">
        <pre class="card-text">{{co}}div class="limiter">
    {{co}}div class="container-login100">
        {{co}}div class="wrap-login100 p-t-50 p-b-90">
            {{co}}form class="login100-form validate-form flex-sb flex-w" <b>{{p}}ngSubmit)="GuardarDatos(variableLocal)" <abbr title="Coge todos los datos y lo lleva al Ts para su procesamiento y le mandamos variableLocal"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> #variableLocal="ngForm" <abbr title="variableLocal -> Para que se pueda hacer las validaciones (required etc y coja los datos) y =ngForm que la trate como ngForm porque tiene muchas propiedades"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr></b>>   

                {{co}}span class="login100-form-title p-b-51">Crear nueva cuenta{{co}}/span>

                {{co}}span class="text-danger" <b>{{f}}ngIf="variableLocal.submitted <abbr title="Si ha sido pulsado el botón submit y (&&)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            && variableLocal.controls['email'].errors" <abbr title="Si el dato introducido da error se muestra, ['email'] -> Está en relación con name=email. Podemos usar todo lo que venga en el ngForm que observamos en pantalla: controls, errors, invalid, ngSubmit, pending, pristine (si no ha sido modificado), statusm touched, valid... "><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> </b>>El correo es obligatorio{{co}}/span>

                {{co}}div class="wrap-input100 m-b-16">
                    {{co}}input class="input100" <b>type="email" <abbr title="nos aparece en el movil la opción de poner @"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              name="email" <abbr title="Obligado para almacenar datos y poder validar errores (como arriba) y otras opciones"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              {{t}}(ngModel)]="usuario.email"</b> <abbr title="Coge el email. .email -> Debe ser igual que en model (usuario.model)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              placeholder="Email" 
                                              <b>required <abbr title="Sino tiene ese valor no acepta el formulario, se ve en un console.log(form) en el Ts en la consola como valid -> false(no rellenado) o true (rellenado)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> email</b> <abbr title="Para que nos obligue a poner @"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                                              <b>email</b> <abbr title="Ponemos email para que nos pida nombre@nombre"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>  
                    {{co}}span class="focus-input100">{{co}}/span>
                {{co}}/div>

                {{co}}span class="text-danger" <b>{{f}}ngIf="variableLocal.submitted <abbr title="Si ha sido pulsado el botón submit y (&&)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            && variableLocal.controls['nombre'].errors"</b> <abbr title="Si el dato introducido da error se muestra, ['nombre'] -> Está en relación con name=nombre. Podemos usar todo lo que venga en el ngForm que observamos en pantalla: controls, errors, invalid, ngSubmit, pending, pristine (si no ha sido modificado), statusm touched, valid... "><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> >El nombre es obligatorio y al menos 2 letras{{co}}/span>
                {{co}}div class="wrap-input100 m-b-16">
                    {{co}}input class="input100" type="text" 
                                            <b>name="nombre" <abbr title="Obligado para almacenar datos y poder validar errores (como arriba) y otras opciones"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              {{t}}(ngModel)]="usuario.nombre"</b> <abbr title="Coge el nombre. .nombre -> Debe ser igual que en model (usuario.model)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              placeholder="Nombre y apellidos" 
                                              <b>required <abbr title="Obligado a rellenar sino no es aceptado el formulario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              minlength="2"</b> <abbr title="Que tenga mínimo 2 letras"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>
              
                    {{co}}span class="focus-input100">{{co}}/span>
                {{co}}/div>
                
                {{co}}span class="text-danger" <b>{{f}}ngIf="variableLocal.submitted <abbr title="Si ha sido pulsado el botón submit y (&&)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            && variableLocal.controls['pass'].errors"</b> <abbr title="Si el dato introducido da error se muestra, ['pass'] -> Está en relación con name=pass. Podemos usar todo lo que venga en el ngForm que observamos en pantalla: controls, errors, invalid, ngSubmit, pending, pristine (si no ha sido modificado), statusm touched, valid... "><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> >El password es obligatorio y al menos 6 letras{{co}}/span>
                {{co}}div class="wrap-input100 m-b-16" data-validate = "Password is required">
                    {{co}}input class="input100" type="password" 
                                            <b>name="pass" <abbr title="Obligado para almacenar datos y poder validar errores (como arriba) y otras opciones"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              {{t}}(ngModel)]="usuario.password"</b> <abbr title="Coge el password. .password -> Debe ser igual que en model (usuario.model)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              placeholder="Password" 
                                              <b>required <abbr title="Obligado a rellenar sino no es aceptado el formulario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                              minlength="6"</b> <abbr title="Que tenga mínimo 6 letras"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>

                    {{co}}span class="focus-input100">{{co}}/span>
                {{co}}/div>
                
                {{co}}div class="flex-sb-m w-full p-t-3 p-b-24">

                    {{co}}div class="contact100-form-checkbox">
                        {{co}}input class="input-checkbox100" id="ckb1" type="checkbox" name="remember-me">
                        {{co}}label class="label-checkbox100" for="ckb1">Recordar mi usuario{{co}}/label>
                    {{co}}/div>

                    {{co}}div>
                        {{co}}a <b>routerLink="/loginloginangular"</b> <abbr title="Nos lleva a la página del login"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> class="txt1">¿Ya tienes cuenta? / Ingresar{{co}}/a>
                    {{co}}/div>

                {{co}}/div>

                {{co}}div class="container-login100-form-btn m-t-17">
                    {{co}}<b>button</b> class="login100-form-btn btn btn-danger" <b>type="submit" <abbr title="Para que haga efecto al pulsar, llama a la función de arriba"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr></b>><b>Crear cuenta</b>{{co}}/button>
                {{co}}/div>

            {{co}}/form>
        {{co}}/div>
    {{co}}/div>
{{co}}/div></pre>
    </div>
</div>
</div>

        </div>


        <div class="tab-pane fade" id="v-pills-firebaseangularfirebase2" role="tabpanel" aria-labelledby="v-pills-firebaseangularfirebase2-tab"><app-loginangularloginfirebase></app-loginangularloginfirebase>
          
<div class="card-group">
  <div class="card text-dark bg-danger m-3">
      <div class="card-header">
          <pre class="card-text text-center blanco"><h3>Servicio</h3></pre>
      </div>
      <div class="card-body">
        <pre class="card-text blanco">import {{c}} Injectable } from '@angular/core';
import {{c}} HttpClient } from '@angular/common/http';  
<b>import {{c}} UsuarioModel } from '../../model/usuario.model';</b>  <abbr title="Model, estructura del usuario: email, password..."><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} catchError <abbr title="Captura el error que salga al no coger el dato, usamos variableError.error.error...depende como venga en la API el error"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> , map <abbr title="Coge los datos que necesitamos ['datoNecesario'] que viene de la API para usarlo, se puede ver en consola cuando llamamos a la API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> } from 'rxjs/operators';</b>  

@Injectable({{c}}
  providedIn: 'root'
})

export class ServiciofireService {{c}}

  private url = 'https://identitytoolkit.googleapis.com/v1/accounts:sign'; 

  private apikey = 'AIzaSyBXBZUhEffME9i58aVvigvAkSoOgCEfSPg'; 

  <b>TokenUsuario: string;</b>  <abbr title="Se inicializa sin valor (undefined) porque hasta que no se identifique no obtenemos ningún token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

   //https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]             //Crear usuario
   //https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY] //Login usuario

  constructor( private http: HttpClient ) {{c}} }  


   <b>login ( usuario: UsuarioModel ){{c}}</b>  <abbr title="En la documentación pone que necesitaremos email, password y token (que debe ser true para que me devuelva). Email y password viene declarado en el Model y por ello en la variable usuario. https://firebase.google.com/docs/reference/rest/auth -> Request Body Payload -> email, password y returnSecureToken"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

      //Compleja                                  
      /*const authData = {{c}}    <abbr title="Como viene incluido en el model email/password tenemos que declarar el token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            email: usuario.email,   <abbr title="Del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            password: usuario.password, <abbr title="Del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
            returnSecureToken: true     <abbr title="Copiamos el token de la web y la declaramos en true"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      };*/              
      
      //Reducida
      <b>const authData = {{c}}</b>  <abbr title="Como viene incluido en el model email/password tenemos que declarar el token"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>...usuario,</b>           <abbr title="Del model. coge todos los elementos (...)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>returnSecureToken: true</b>  <abbr title="Copiamos el token de la web y la declaramos en true"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
  }; 
  
    //LLAMA A NUESTRO SERVICIO HTTP POST PARA CREAR

    //Compleja
    /*return this.http.post(    <abbr title="return -> Para poderme subscribirme en otro lugar"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      `${{c}} this.url }InWithPassword?key=${{c}} this.apikey }`,   <abbr title="Dirección donde hacemos el post y usamos el servicio API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      authData  <abbr title="Argumento que le enviamos a la dirección (email, password y token)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    );*/

    //Reducida
    <b>return this.http.post(this.url + 'InWithPassword?key=' + this.apikey, authData)<abbr title="Dirección común + no común + apikey personal, datos que enviamos"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>//;</b> <abbr title="Quitamos; al añadir pipe + map"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>  
                      <b>.pipe(</b> <abbr title="Tubería donde cogemos todos los datos de la API"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

                            <b>map( resp => {{c}}</b>   <abbr title="Dentro del Pipe nos permite usar el map (Transforma la información como queramos o servir solo de intermediario, lee la respuesta y si viene el token lo almacena. La ventaja del map que si el post da un error no se va a disparar)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                              console.log('Entro en el pipe -> map'); 
                              <b>this.guardarToken ( resp ['idToken']);</b> <abbr title="Voy a mandar a guardarToken el ID del token que es lo que obtengo de la API, debe ser exactamente igual escrito"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                              <b>return resp;</b>  <abbr title="Meto en una tuvería (pipe) y filtro (map) lo que quiero obtener (['idToken'])"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                          <b>})</b>/*<b>,</b>

                          <b>catchError(err => {{c}}</b>   <abbr title="Se podría controlar el error, pero ya lo controlamos en el Ts. SI QUEREMOS CONTROLAR EL ERROR AQUÍ O EN EL TS"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                            console.log(<b>err.error.error.message</b>);  <abbr title="Saca el mensaje del error, en este caso es: EMAIL_EXISTS. Sabemos que son varios error al mirar en consola, vemos error y dentro otro error..."><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                            <b>return err;</b>  <abbr title="Sale con el error"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                          <b>})</b>*/
                         <b>);</b>
    <b>}</b>

    /*GUARDAR/LEER  TOKEN*/

    <b>private guardarToken ( IDToken_Recibido: string ){{c}}</b>  <abbr title="Donde guardaremos el Token que recibimos del registro/login cuando es llamado, para luego leerlo y usarlo"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      <b>this.TokenUsuario = IDToken_Recibido; </b> <abbr title="El Id del token recibido lo metemos en la variable TokenUsuario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      <b>localStorage.setItem('AlmacenaToken', IDToken_Recibido);</b> <abbr title="ID Token lo almacenamos en AlmacenaToken, su forma es un string y lo cogemos del IDToken_Recibido"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    <b>}
  
  
  
    leerToken(){{c}}
        if( localStorage.getItem('AlmacenaToken') ){{c}}</b>  <abbr title="Si existe el token que es dado al guardarlo a través de guardarToken"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
          <b>this.TokenUsuario = localStorage.getItem('AlmacenaToken');</b>  <abbr title="Metemos en la variable el token que está almacenado si coincide por la condición de arriba"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>}
        else{{c}}</b>  <abbr title="Si no existe el token almacenado"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
          <b>this.TokenUsuario = '';</b>  <abbr title="Lo inicializamos en vacío"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>}
  
        return this.TokenUsuario;</b>  <abbr title="Devolvemos la variable del token tenga (if) o no tenga (else) token almacenado"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    <b>}</b>

}</pre>
      </div>
  </div>
</div>

<div class="card-group">
    <div class="card text-dark bg-primary m-3">
        <div class="card-header">
            <pre class="card-text text-center"><h3>Ts</h3></pre>
        </div>
        <div class="card-body">
          <pre class="card-text">import {{c}} Component, OnInit } from '@angular/core';
<b>import {{c}} UsuarioModel } from '../../model/usuario.model';</b>  <abbr title="Model del usuario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} NgForm } from '@angular/forms';</b>  <abbr title="Funciones para formularios"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
<b>import {{c}} ServiciofireService } from '../servicio/serviciofire.service';</b>  <abbr title="Servicio donde llamamos a la API y de ese modo conectarnos con el componente"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

@Component({{c}}
  selector: 'app-loginangularloginfirebase',
  templateUrl: './loginangularloginfirebase.component.html',
  styleUrls: ['./loginangularloginfirebase.component.css']
})
export class LoginangularloginfirebaseComponent implements OnInit {{c}}

  <b>usuario: UsuarioModel = new UsuarioModel();</b>  <abbr title="Variable dandole formato del model"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

  constructor( <b>private auth: ServiciofireService</b> ) {{c}} }  <abbr title="Variable que metemos el servicio dentro"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>

  ngOnInit(): void {{c}}
  }

  <b>loginTs( datoRecibido: NgForm ){{c}}</b>  <abbr title="Función que comprueba lo que metemos en el formulario mandandolo al servicio y este a la API de firebase para comprobar si está o no"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    <b>if ( datoRecibido.invalid ){{c}}</b>  <abbr title="Si el formulario introducido es invalido se sale"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
        <b>return;</b>
    <b>}
    
    this.auth.login(this.usuario).subscribe ( resp => {{c}}</b>
      console.log(<b>resp</b>);
      
    <b>},</b> (<b>variableRecibirError</b>) <b>=> {{c}}</b>  <abbr title="Coge el error recibido. SI QUEREMOS CONTROLAR EL ERROR AQUÍ O EN EL SERVICIO. RECOMEDABLE AQUÍ"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
      console.log(<b>variableRecibirError.error.error.message</b>);  <abbr title="Muestra el mensaje del error"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
    <b>}</b>
    
    <b>);</b>
    
  <b>}</b>
}</pre>
        </div>
    </div>
    <div class="card text-dark bg-warning m-3">
      <div class="card-header">
          <pre class="card-text text-center"><h3>Html</h3></pre>
      </div>
      <div class="card-body">
          <pre class="card-text">{{co}}div class="limiter">
    {{co}}div class="container-login100">
        {{co}}div class="wrap-login100 p-t-50 p-b-90">
            {{co}}form class="login100-form validate-form flex-sb flex-w" <b>{{p}}ngSubmit)="loginTs(variableLocal)"</b> <abbr title="Coge todos los datos y lo lleva al Ts para su procesamiento y le mandamos variableLocal"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                                                                        <b>#variableLocal="ngForm"</b> <abbr title="variableLocal -> Para que se pueda hacer las validaciones (required etc y coja los datos) y =ngForm que la trate como ngForm porque tiene muchas propiedades"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>

                {{co}}span class="login100-form-title p-b-51">Login{{co}}/span>

                {{co}}span class="text-danger" <b>{{f}}ngIf="variableLocal.submitted</b>  <abbr title="Si ha sido pulsado el botón submit y (&&)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            <b>&& variableLocal.controls['email'].errors"</b> <abbr title="Si el dato introducido da error se muestra, ['email'] -> Está en relación con name=email. Podemos usar todo lo que venga en el ngForm que observamos en pantalla: controls, errors, invalid, ngSubmit, pending, pristine (si no ha sido modificado), statusm touched, valid... "><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>El correo es obligatorio{{co}}/span>
                {{co}}div class="wrap-input100 m-b-16">
                    {{co}}input class="input100" type="<b>email</b>" 
                                            <b>name="email"</b> <abbr title="Obligado para almacenar datos y poder validar errores (como arriba) y otras opciones"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            <b>{{t}}(ngModel)]="usuario.email"</b> <abbr title="Coge el email. .email -> Debe ser igual que en model (usuario.model)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            placeholder="email"
                                            <b>required</b> <abbr title="Obligado a rellenar sino no es aceptado el formulario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>
                                            <b>email</b> <abbr title="Ponemos email para que nos pida nombre@nombre"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> >

                    {{co}}span class="focus-input100">{{co}}/span>
                {{co}}/div>
                
                {{co}}span class="text-danger" <b>{{f}}ngIf="variableLocal.submitted</b> 
                                            <b>&& variableLocal.controls['pass'].errors"</b> <abbr title="Si el dato introducido da error se muestra, ['pass'] -> Está en relación con name=pass. Podemos usar todo lo que venga en el ngForm que observamos en pantalla: controls, errors, invalid, ngSubmit, pending, pristine (si no ha sido modificado), statusm touched, valid... "><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>La contraseña es obligatoria y necesita un mínimo de 6 letras{{co}}/span>
                {{co}}div class="wrap-input100 m-b-16" data-validate = "Password is required">
                    {{co}}input class="input100" type="<b>password</b>" 
                                            <b>name="pass"</b> <abbr title="Obligado para almacenar datos y poder validar errores (como arriba) y otras opciones"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            <b>{{t}}(ngModel)]="usuario.password"</b> <abbr title="Coge el password. .password -> Debe ser igual que en model (usuario.model)"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            placeholder="Password"
                                            <b>required</b> <abbr title="Obligado a rellenar sino no es aceptado el formulario"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> 
                                            <b>minlength="6"</b> <abbr title="Que tenga mínimo 6 letras"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr>>
                    {{co}}span class="focus-input100">{{co}}/span>
                {{co}}/div>
                
                {{co}}div class="flex-sb-m w-full p-t-3 p-b-24">
                    {{co}}div class="contact100-form-checkbox">
                        {{co}}input class="input-checkbox100" id="ckb1" type="checkbox" name="remember-me">
                        {{co}}label class="label-checkbox100" for="ckb1">Recordar mi usuario{{co}}/label>
                    {{co}}/div>

                    {{co}}div>
                        {{co}}a <b>routerLink="/registroregistroangular"</b> <abbr title="Nos lleva a la página del registro"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr> class="txt1">¿No tienes cuenta?{{co}}/a>
                    {{co}}/div>
                {{co}}/div>

                {{co}}div class="container-login100-form-btn m-t-17">
                    {{co}}<b>button</b> class="login100-form-btn btn btn-danger" <b>type="submit" <abbr title="Para que haga efecto al pulsar, llama a la función de arriba"><i class="fa fa-question-circle" aria-hidden="true"></i></abbr></b>>Ingresar{{co}}/button>
                {{co}}/div>

            {{co}}/form>
        {{co}}/div>
    {{co}}/div>
{{co}}/div></pre>
      </div>
  </div>
</div>

</div>


<div class="tab-pane fade" id="v-pills-firebaseangularfirebase3" role="tabpanel" aria-labelledby="v-pills-firebaseangularfirebase3-tab">x</div>


        </div>
    </div>
</div>



<button class="btn btn-success m-5" [routerLink]="['/instalacionfirebase']">Instalación</button>